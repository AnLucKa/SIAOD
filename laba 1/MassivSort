package com.company;

import java.util.Arrays;

public class MassivSort {

    public static void sort1(int[][] arr) {//сортировка выбором
        int x = arr[0].length; //ширина
        int y = arr.length; //высота
        for (int l = 0; l < y; l++) {
            for (int i = 0; i < x; i++) {
                int min = arr[l][i];
                int min_i = i;
                for (int j = i + 1; j < arr.length; j++) {
                    if (arr[l][j] <min){
                        min = arr[l][j];
                        min_i = j;
                    }
                }
                if (i != min_i) {
                    swap(arr[l], i, min_i);
                }
            }
        }
    }

    public static void sort2(int[][] arr) { //сортировка вставкой
        int x = arr[0].length; //ширина
        int y = arr.length; //высота
        int value;
        for (int i = 0; i < y; i++) { //проходимя по строкам
            for (int left = 0; left < x; left++) { //проходимся по элементам в строке
                value = arr[i][left];
                int j = left - 1;
                for (; j >= 0; j--) {
                    if (value < arr[i][j]) {
                        arr[i][j + 1] = arr[i][j];
                    } else {
                        break;
                    }
                }
                arr[i][j + 1] = value;
            }
        }
    }

    public static void sort3 (int[][] arr){ //сортировка обменом
        int x = arr[0].length; //ширина
        int y = arr.length; //высота
        for (int l = 0; l < y; l++) {
            for (int i = x - 1; i >=1; i--){
                for (int j = 0; j < i; j++){
                    if (arr[l][j] > arr[l][j + 1]) {
                        swap(arr[l], j, j + 1);
                    }

                }
            }
        }
    }

    public static void sort4 (int[][] arr) { //сортировка Шелли
        int x = arr[0].length; //ширина
        int y = arr.length; //высота
        for (int i = 0; i < y; i++) { //проходимя по строкам
            int h = x / 2;
            int value,j,k;
            while (h >= 1) {
                for (j = h; j < x; j++) { //проходимся по элементам в строке
                    value=arr[i][j];
                    for (k = j; k >= h; k-= h) {
                        if (value < arr[i][k-h])
                            arr[i][k]= arr[i][k-h];
                        else
                            break;
                    }
                    arr[i][k]= value;
                }
                h = h / 2;
            }
        }
    }
    public static void sort5(int[][] arr) { //сортировка быстрая
        int x = arr[0].length; //ширина
        int y = arr.length; //высота
        for (int i = 0; i < y; i++) {
            int[] stroka = arr[i];
            quickSort(stroka, 0, stroka.length - 1);
        }
    }
    private static void quickSort (int[] stroka, int leftBorder, int rightBorder){
        int leftMarker = leftBorder;
        int rightMarker = rightBorder;
        int op = stroka[(leftMarker + rightMarker) / 2];
        do {
            // Двигаем левый маркер слева направо пока элемент меньше, чем pivot
            while (stroka[leftMarker] < op) {
                leftMarker++;
            }
            // Двигаем правый маркер, пока элемент больше, чем pivot
            while (stroka[rightMarker] > op) {
                rightMarker--;
            }
            // Проверим, не нужно обменять местами элементы, на которые указывают маркеры
            if (leftMarker <= rightMarker) {
                // Левый маркер будет меньше правого только если мы должны выполнить swap
                if (leftMarker < rightMarker) {
                    swap (stroka, leftMarker, rightMarker);
                }
                // Сдвигаем маркеры, чтобы получить новые границы
                leftMarker++;
                rightMarker--;
            }
        } while (leftMarker <= rightMarker);

        // Выполняем рекурсивно для частей
        if (leftMarker < rightBorder) {
            quickSort(stroka, leftMarker, rightBorder);
        }
        if (leftBorder < rightMarker) {
            quickSort(stroka, leftBorder, rightMarker);
        }
    }

    private static int heapSize ;
    public static void sort6 (int[][] arr) { //сортировка пирамидальная
        int x = arr[0].length; //ширина
        int y = arr.length; //высота
        int rr[] = new int [x];

        for(int i = 0; i < y; i++){

            for (int j = 0; j < x; j++){
                rr[j]  = arr[i][j];
            }
            buildHeap(rr);
            while (heapSize > 1) {
                swap(rr, 0, heapSize - 1);
                heapSize--;
                heapify(rr,0);
            }
            for(int j = 0; j < x; j++){
                arr[i][j] = rr[j];
            }
        }
    }
    private static void buildHeap(int[] a) {
        heapSize = a.length; //длина кучи
        for (int i = a.length / 2; i >= 0; i--) {
            heapify(a, i);
        }
    }
    private static void heapify(int[] rr, int i) {
        int r = 2 * i + 2;
        int l = 2 * i + 1;
        int largest = i;
        if (r < heapSize && rr[i] < rr[r]) {
            largest = r;
        }
        if (l < heapSize && rr[largest] < rr[l]) {
            largest = l;
        }
        if (i != largest) {
            swap(rr, i, largest);
            heapify(rr, largest);
        }
    }

    public static void swap(int[] array, int ind1, int ind2) {
        int tmp = array[ind1];
        array[ind1] = array[ind2];
        array[ind2] = tmp;
    }
    public static void massivOut(int[][] arr) {
        for (int[] line : arr) {
            for (int elem : line) {
                System.out.print(elem + "   \t");
            }
            System.out.println();
        }
    }
}
